Java垃圾收集算法

首先需要了解垃圾标记算法

	垃圾标记算法，内部分为两种算法：引用标记算法、根搜索算法
	
	1）引用标记算法
		标记对象的引用，当无引用时，即为垃圾。
		缺点：在互相引用的时候会导致无法回收。
	
	2）根搜索算法
		选定根节点，相当于所有引用的祖先，当子节点失去与父节点的引用，则子节点间无论有多少引用，都无法到达根节点，即为垃圾。

![根搜索算法](https://raw.githubusercontent.com/xyoye/xyoye.github.io/master/image/2019-4-9/根搜索算法.png)

Java内部垃圾回收主要采用：分代回收算法
	
	内部包括：标记清除算法、复制算法、标记压缩算法
	
	1）标记清除算法
		标记可清除的对象，回收标记的对象。
		缺点：标记与回收效率不高，产生大量内存碎片，导致没有连续的内存分配给大对象，从而再次引起垃圾回收

![标记清除算法](https://raw.githubusercontent.com/xyoye/xyoye.github.io/master/image/2019-4-9/标记-清除算法.png)

	2）复制算法
		将内存区域分为两半，每次只使用其中一半，在回收时，将使用的一半中存活对象复制到未使用的一半中（我更倾向于表达为移动），再回收使用的一半中可回收的对象。
		缺点：将内存分为两半，直接减少了可使用的内存。

![复制算法](https://raw.githubusercontent.com/xyoye/xyoye.github.io/master/image/2019-4-9/复制算法.png)

	3）标记压缩算法
		与标记清除算法类似，但是在回收标记对象后，将存活对象压缩到一端，将存活对象内存边缘外的对象回收。

![标记压缩算法](https://raw.githubusercontent.com/xyoye/xyoye.github.io/master/image/2019-4-9/标记-压缩算法.png)

分代回收算法中将内存区域划分为新生代、老年代以及永久代(jdk8后取消了永久代，取而代之的是元空间)，其中新生代又细分为三部分：Eden、Form Survivor、To Survivor。
	
	eden与两个survivor的比例大致为1:8
	
	根据分代的堆区划分了两种垃圾回收器：
	1）Minor Collection : 新生代垃圾回收器
	2）Full Collection ： 又称Majjor Collection，对新生代、老年代(Full Collection扫描不到元空间）。相对于另一个垃圾回收器，它收集频率较低，耗时较长。
	
	执行Full Collection时，采用的是标记压缩算法
	执行Minor Collection时，采用的是复制算法
	1）Eden存活对象 -> To Survivor
	2）Form Survivor存活对象 -> To Survivor 或 永久代
	3）将Form Survivor区域与To Survivor区域对调


![新生代垃圾回收](https://raw.githubusercontent.com/xyoye/xyoye.github.io/master/image/2019-4-9/新生代垃圾收集.png)

	从From Survivor复制对象到永久代的条件为：
	1）存活的对象的分代年龄超过-XX:MaxTenuringThreshold（用于控制对象经历多少次Minor GC才晋升到老年代）。
	2）To Survivor空间容量达到阈值。
	
	